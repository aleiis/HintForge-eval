{
  "context": "# Scalar types\nscalar Counts\nscalar Tags\nscalar Geometry\nscalar Time\nscalar Date\nscalar Point\nscalar LineString\nscalar Seconds\nscalar Polygon\nscalar Map\nscalar Any\nscalar Upload\nscalar Key\nscalar Bool\nscalar Strings\n\n# Force resolver\ndirective @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION\n\n# Root query and mutation\n\ntype Query {\n  feed_versions(limit: Int, after: Int, ids: [Int!], where: FeedVersionFilter): [FeedVersion!]!\n  feeds(limit: Int, after: Int, ids: [Int!], where: FeedFilter): [Feed!]!\n  agencies(limit: Int, after: Int, ids: [Int!], where: AgencyFilter): [Agency!]!\n  routes(limit: Int, after: Int, ids: [Int!], where: RouteFilter): [Route!]!\n  stops(limit: Int, after: Int, ids: [Int!], where: StopFilter): [Stop!]!\n  trips(limit: Int, after: Int, ids: [Int!], where: TripFilter): [Trip!]!\n  operators(limit: Int, after: Int, ids: [Int!], where: OperatorFilter): [Operator!]!\n  directions(where: DirectionRequest!): Directions!\n  bikes(limit: Int, where: GbfsBikeRequest): [GbfsFreeBikeStatus!]\n  docks(limit: Int, where: GbfsDockRequest): [GbfsStationInformation!]\n  places(limit: Int,after: Int, level: PlaceAggregationLevel, where: PlaceFilter): [Place!]\n  me: Me!\n}\n\ntype Mutation {\n    validate_gtfs(file: Upload, url: String, realtime_urls: [String!]): ValidationReport\n    feed_version_update(id: Int!, set: FeedVersionSetInput!): FeedVersion\n    feed_version_fetch(file: Upload, url: String, feed_onestop_id: String!): FeedVersionFetchResult\n    feed_version_import(id: Int!): FeedVersionImportResult!\n    feed_version_unimport(id: Int!): FeedVersionUnimportResult!\n    feed_version_delete(id: Int!): FeedVersionDeleteResult!\n}\n\ntype Me {\n  id: String!\n  name: String\n  email: String\n  roles: [String!]\n  external_data: Map\n}\n\n\"\"\"\nFeeds contain details on how to access transit information, including URLs to data sources in various formats (GTFS, GTFS-RT, GBFS, etc), license information, related feeds, details on how to make authorized requests, and feed version archives. Feed versions are archived (as `.zip` files) and imported into the Transitland database for querying agencies, stops, routes, trips, etc.\n\"\"\"\ntype Feed {\n  \"Unique integer ID\"\n  id: Int!\n  \"Onestop ID for this feed\"\n  onestop_id: String!\n  \"A common name for this feed. Optional. Alternatively use `associated_operators[].name`\"\n  name: String\n  file: String!\n  spec: FeedSpecTypes\n  \"Language(s) included in this feed\"\n  languages: [String!]\n  tags: Tags\n  authorization: FeedAuthorization\n  urls: FeedUrls\n  license: FeedLicense\n  search_rank: String # only for search results\n  associated_operators: [Operator!]\n  feed_state: FeedState\n  feed_fetches(limit: Int, where: FeedFetchFilter): [FeedFetch!]\n  \"Versions of this feed that have been fetched, archived, and imported by Transitland\"\n  feed_versions(limit: Int, where: FeedVersionFilter): [FeedVersion!]!\n}\n\n\"\"\"\nDetails on the current state of this feed, such as active version, last fetch time, etc.\n\"\"\"\ntype FeedState {\n  id: Int!\n  \"The active feed version for this feed\"\n  feed_version: FeedVersion\n}\n\ntype FeedFetch {\n  id: Int!\n  url_type: String\n  url: String\n  success: Boolean\n  fetched_at: Time\n  fetch_error: String\n  response_size: Int\n  response_code: Int\n  response_sha1: String\n}\n\n\"\"\"\nDetails on how to construct an HTTP request to access a protected resource\n\"\"\"\ntype FeedAuthorization {\n  \"Method for inserting authorization secret into request\"\n  type: String!\n  \"When `type=query_param`, this specifies the name of the query parameter. When `type=header`, this specifies the name of the header\"\n  param_name: String!\n  \"Website to visit to sign up for an account\"\n  info_url: String!\n}\n\n\"\"\"\nLicense information for this feed, curated by Interline and contributors to the Transitland Atlas feed registry. Note that this does not constitute legal advice. Users are advised to review and confirm any terms and conditions attached to a source feed.\n\"\"\"\ntype FeedLicense {\n  \"SPDX identifier for a common license. See https://spdx.org/licenses/\"\n  spdx_identifier: String!\n  \"URL for a custom license\"\n  url: String!\n  \"Are feed consumers allowed to use the feed contents without including attribution text in their app or map?\"\n  use_without_attribution: String!\n  \"Are feed consumers allowed to create and share derived products from the feed?\"\n  create_derived_product: String!\n  \"Are feed consumers allowed to redistribute the feed in its entirety?\"\n  redistribution_allowed: String!\n  \"Are feed consumers allowed to use the feed for commercial purposes?\"\n  commercial_use_allowed: String!\n  \"Are feed consumers allowed to keep their modifications of this feed private?\"\n  share_alike_optional: String!\n  \"Feed consumers must include this particular text when using this feed\"\n  attribution_text: String!\n  \"Feed consumers must follow these instructions for how to provide attribution\"\n  attribution_instructions: String!\n}\n\n\"\"\"\nURL(s) from which Transitland sources a feed\n\"\"\"\ntype FeedUrls {\n  \"URL for the static feed that represents today's service\"\n  static_current: String!\n  \"URLs for static feeds that represent past service that is no longer in effect \"\n  static_historic: [String!]!\n  \"URLs for static feeds that represent service planned for upcoming dates. Typically used to represent calendar/service changes that will take effect few weeks or months in the future\"\n  static_planned: String!\n  \"URL for GTFS Realtime VehiclePosition messages\"\n  realtime_vehicle_positions: String!\n  \"URL for GTFS Realtime TripUpdate messages\"\n  realtime_trip_updates: String!\n  \"URL for GTFS Realtime Alert messages\"\n  realtime_alerts: String!\n  \"URL for GBFS feed `gbfs.json` auto-discovery file\"\n  gbfs_auto_discovery: String!\n  \"URL for MDS feed provider endpoint\"\n  mds_provider: String!\n}\n\n\"\"\"\nFeed versions represent a specific static GTFS file that was published at a particular point in time, and are generally accessed and referenced using the [SHA1 checksum](https://en.wikipedia.org/wiki/SHA-1) of the GTFS archive.\n\"\"\"\ntype FeedVersion {\n  id: Int!\n  sha1: String!\n  fetched_at: Time!\n  url: String!\n  earliest_calendar_date: Date!\n  latest_calendar_date: Date!\n  created_by: String\n  updated_by: String\n  name: String\n  description: String\n  file: String  \n  \"Convex hull around all active stops in the feed version\"\n  geometry: Polygon\n  feed: Feed!\n  feed_version_gtfs_import: FeedVersionGtfsImport\n  \"Metadata for each text file present in the main directory of the zip archive \"\n  files(limit: Int): [FeedVersionFileInfo!]!\n  service_levels(limit: Int, where: FeedVersionServiceLevelFilter): [FeedVersionServiceLevel!]!\n  agencies(limit: Int, where: AgencyFilter): [Agency!]!\n  routes(limit: Int, where: RouteFilter): [Route!]!\n  stops(limit: Int, where: StopFilter): [Stop!]!\n  trips(limit: Int, where: TripFilter): [Trip!]!\n  feed_infos(limit: Int): [FeedInfo!]!\n  validation_reports(limit: Int, where: ValidationReportFilter): [ValidationReport!]\n}\n\ntype FeedVersionFileInfo {\n  id: Int!\n  name: String!\n  rows: Int!\n  sha1: String!\n  header: String!\n  csv_like: Boolean!\n  size: Int!\n  values_count: Counts!\n  values_unique: Counts!\n}\n\ntype FeedVersionGtfsImport {\n  id: Int!\n  in_progress: Boolean!\n  success: Boolean!\n  schedule_removed: Boolean!\n  exception_log: String!\n  skip_entity_error_count: Any\n  entity_count: Any\n  warning_count: Any\n  created_at: Time\n  updated_at: Time\n  skip_entity_reference_count: Any\n  skip_entity_filter_count: Any\n  skip_entity_marked_count: Any\n  interpolated_stop_time_count: Int\n}\n\ntype FeedVersionServiceLevel {\n  id: Int!\n  start_date: Date!\n  end_date: Date!\n  monday: Int!\n  tuesday: Int!\n  wednesday: Int!\n  thursday: Int!\n  friday: Int!\n  saturday: Int!\n  sunday: Int!\n}\n\n# Operator\n\"\"\"\nAn agency represents a single GTFS `agencies.txt` entity that was imported from a single feed version. The metadata, routes, etc., for an agency include only the data for that specific agency in that specific feed version. \n\nOperators are a higher-level abstraction over agencies, with each operator defined by an entry in the [Transitland Atlas](/documentation/atlas). Operators provide a method for enriching the basic GTFS agency data, as well as grouping agencies that span across multiple source feeds. Operators are matched with GTFS agencies using `associated_feeds`, a simple list of Feed OnestopIDs and GTFS `agency_id`s. For instance, the [Atlas operator record](https://github.com/transitland/transitland-atlas/blob/master/operators/o-dr5r-nyct.json) for the [New York City MTA](/operators/o-dr5r-nyct) has `associated_feeds` values for 8 different GTFS feeds. A query for this operator OnestopID thus represents the union of data from all 8 feeds, and includes routes for the subway, bus service for all 5 boroughs, commuter rail agencies, etc., operated by the MTA. This record also includes additional metadata about the MTA, such as the United States National Transit Database ID, Wikidata IDs, and alternate names for the agency. Operator records are created and maintained through pull requests to the Atlas json files and synchronized with the Transitland database on each commit.\n\"\"\"\ntype Operator {\n  id: Int!\n  generated: Boolean!\n  file: String\n  onestop_id: String\n  name: String\n  short_name: String\n  website: String\n  tags: Tags\n  search_rank: String # only for search results\n  agencies: [Agency!]\n  feeds(limit: Int, where: FeedFilter): [Feed!]\n}\n\n# GTFS Entities\n\n\"\"\"\nSee https://gtfs.org/schedule/reference/#agencytxt\n\"\"\"\ntype Agency {\n  id: Int!\n  onestop_id: String!\n  agency_email: String!\n  agency_fare_url: String!\n  agency_id: String!\n  agency_lang: String!\n  agency_name: String!\n  agency_phone: String!\n  agency_timezone: String!\n  agency_url: String!\n  feed_version_sha1: String\n  feed_onestop_id: String\n  feed_version: FeedVersion!\n  geometry: Polygon\n  search_rank: String # only for search results\n  operator: Operator\n  places(limit: Int, where: AgencyPlaceFilter): [AgencyPlace!]\n  routes(limit: Int, where: RouteFilter): [Route!]!\n  census_geographies(layer: String!, radius: Float, limit: Int): [CensusGeography!]\n  alerts(active: Boolean, limit: Int): [Alert!]\n}\n\n\"\"\"\nSee https://gtfs.org/schedule/reference/#routestxt\n\"\"\"\ntype Route {\n  id: Int!\n  onestop_id: String\n  route_id: String!\n  route_short_name: String!\n  route_long_name: String!\n  route_type: Int!\n  route_color: String!\n  route_text_color: String!\n  route_sort_order: Int!\n  route_url: String!\n  route_desc: String!\n  continuous_pickup: Int\n  continuous_drop_off: Int\n  geometry: Geometry @goField(forceResolver: true)\n  agency: Agency!\n  feed_version: FeedVersion!\n  feed_version_sha1: String!\n  feed_onestop_id: String!\n  search_rank: String # only for search results\n  route_attribute: RouteAttribute\n  trips(limit: Int, where: TripFilter): [Trip!]!\n  stops(limit: Int, where: StopFilter): [Stop!]!\n  route_stops(limit: Int): [RouteStop!]!\n  headways(limit: Int): [RouteHeadway!]!\n  geometries(limit: Int): [RouteGeometry!]!\n  census_geographies(layer: String!, radius: Float, limit: Int): [CensusGeography!]\n  route_stop_buffer(radius: Float): RouteStopBuffer!\n  patterns: [RouteStopPattern!]\n  alerts(active: Boolean, limit: Int): [Alert!]\n}\n\n\"\"\"\nSee https://gtfs.org/reference/static/#stopstxt\n\"\"\"\ntype Stop {\n  id: Int!\n  onestop_id: String!\n  location_type: Int!\n  stop_code: String!\n  stop_desc: String!\n  stop_id: String!\n  stop_name: String!\n  stop_timezone: String!\n  stop_url: String!\n  wheelchair_boarding: Int!\n  zone_id: String!\n  platform_code: String\n  tts_stop_name: String\n  geometry: Point!\n  feed_version_sha1: String!\n  feed_onestop_id: String!\n  feed_version: FeedVersion!\n  level: Level\n  parent: Stop\n  external_reference: StopExternalReference  \n  observations(limit: Int, where: StopObservationFilter): [StopObservation!]\n  children(limit: Int): [Stop!]\n  route_stops(limit: Int): [RouteStop!]!\n  pathways_from_stop(limit: Int): [Pathway!]!\n  pathways_to_stop(limit: Int): [Pathway!]!\n  stop_times(limit: Int, where: StopTimeFilter): [StopTime!]!\n  departures(limit: Int, where: StopTimeFilter): [StopTime!]!\n  arrivals(limit: Int, where: StopTimeFilter): [StopTime!]!\n  search_rank: String # only for search results\n  place: StopPlace\n  census_geographies(layer: String!, radius: Float, limit: Int): [CensusGeography!]\n  directions(to:WaypointInput, from: WaypointInput, mode: StepMode, depart_at: Time): Directions!\n  nearby_stops(limit: Int, radius: Float): [Stop!]\n  alerts(active: Boolean, limit: Int): [Alert!]\n}\n\n\"\"\"\nThe GTFS-Pathways extension uses a graph representation to describe subway or train, with nodes (the locations) and edges (the pathways). See https://gtfs.org/reference/static/#pathwaystxt\n\"\"\"\ntype Pathway {\n  id: Int!\n  pathway_id: String!\n  pathway_mode: Int!\n  is_bidirectional: Int!\n  length: Float!\n  traversal_time: Int!\n  stair_count: Int!\n  max_slope: Float!\n  min_width: Float!\n  signposted_as: String!\n  reverse_signposted_as: String!\n  from_stop: Stop!\n  to_stop: Stop!\n}\n\n\"\"\"\nDescribe the different levels of a station. Is mostly useful when used in conjunction with pathways. See https://gtfs.org/reference/static/#levelstxt\n\"\"\"\ntype Level {\n  id: Int!\n  level_id: String!\n  level_name: String!\n  level_index: Float!\n  geometry: Polygon!\n  stops: [Stop!]\n}\n\n\"\"\"\nRecord from a static GTFS [trips.txt](https://gtfs.org/schedule/reference/#tripstxt) file optionally enriched with by GTFS Realtime [TripUpdate](https://gtfs.org/reference/realtime/v2/#message-tripupdate) and [Alert](https://gtfs.org/reference/realtime/v2/#message-alert) messages.\n\"\"\"\ntype Trip {\n  id: Int!\n  trip_id: String!\n  trip_headsign: String!\n  trip_short_name: String!\n  direction_id: Int!\n  block_id: String!\n  wheelchair_accessible: Int!\n  bikes_allowed: Int!\n  stop_pattern_id: Int!\n  calendar: Calendar!\n  route: Route!\n  shape: Shape\n  feed_version: FeedVersion!\n  stop_times(limit: Int, where: TripStopTimeFilter): [StopTime]!\n  frequencies(limit: Int): [Frequency!]!\n  # rt\n  schedule_relationship: ScheduleRelationship\n  timestamp: Time\n  alerts(active: Boolean, limit: Int): [Alert!]\n}\n\n\"\"\"\nRecord from a static GTFS [calendars.txt](https://gtfs.org/schedule/reference/#calendarstxt) file.\n\"\"\"\ntype Calendar {\n  id: Int!\n  service_id: String!\n  start_date: Date!\n  end_date: Date!\n  monday: Int!\n  tuesday: Int!\n  wednesday: Int!\n  thursday: Int!\n  friday: Int!\n  saturday: Int!\n  sunday: Int!\n  added_dates(limit: Int): [Date!]!\n  removed_dates(limit: Int): [Date!]!\n}\n\n\"\"\"\nRecord from a static GTFS [shapes.txt](https://gtfs.org/schedule/reference/#shapestxt) file.\n\"\"\"\ntype Shape {\n  id: Int!\n  shape_id: String!\n  geometry: LineString!\n  generated: Boolean!\n}\n\n\"\"\"\nRecord from a static GTFS [frequencies.txt](https://gtfs.org/schedule/reference/#frequenciestxt) file.\n\"\"\"\ntype Frequency {\n  id: Int!\n  start_time: Seconds!\n  end_time: Seconds!\n  headway_secs: Int!\n  exact_times: Int!\n}\n\n\"\"\"\nRecord from a static GTFS [stop_times.txt](https://gtfs.org/schedule/reference/#stop_timestxt) file.\n\"\"\"\ntype StopTime {\n  arrival_time: Seconds!\n  departure_time: Seconds!\n  stop_sequence: Int!\n  stop_headsign: String\n  pickup_type: Int\n  drop_off_type: Int\n  timepoint: Int\n  interpolated: Int\n  stop: Stop!\n  trip: Trip!\n  arrival: StopTimeEvent!\n  departure: StopTimeEvent!\n  continuous_drop_off: Int\n  continuous_pickup: Int\n  shape_dist_traveled: Float\n  service_date: Date\n}\n\n\"\"\"\nRecord from a static GTFS [feed_info.txt](https://gtfs.org/schedule/reference/#feed_infotxt) file.\n\"\"\"\ntype FeedInfo {\n  id: Int!\n  feed_publisher_name: String!\n  feed_publisher_url: String!\n  feed_lang: String!\n  default_lang: String\n  feed_version: String!\n  feed_start_date: Date\n  feed_end_date: Date\n  feed_contact_email: String\n  feed_contact_url: String\n}\n\n# Archived observed stop-times\n\ntype StopObservation {\n  schedule_relationship: String\n  trip_start_date: Date\n  trip_start_time: Seconds\n  from_stop_id: String\n  to_stop_id: String\n  agency_id: String\n  route_id: String\n  trip_id: String\n  stop_sequence: Int\n  source: String\n  scheduled_arrival_time: Seconds\n  scheduled_departure_time: Seconds\n  observed_arrival_time: Seconds\n  observed_departure_time: Seconds\n}\n\n# GTFS Support Entities\n\ntype StopExternalReference {\n  id: Int!\n  target_feed_onestop_id: String\n  target_stop_id: String\n  inactive: Boolean\n  target_active_stop: Stop\n}\n\ntype StopPlace {\n  adm1_name: String\n  adm0_name: String\n  adm0_iso: String\n  adm1_iso: String\n}\n\ntype AgencyPlace {\n  city_name: String\n  adm0_name: String\n  adm1_name: String\n  adm0_iso: String\n  adm1_iso: String\n  rank: Float\n}\n\nenum PlaceAggregationLevel {\n  ADM0\n  ADM0_ADM1\n  ADM0_ADM1_CITY\n  ADM0_CITY\n  ADM1_CITY\n  CITY\n}\n\ntype Place {\n  adm0_name: String\n  adm1_name: String\n  city_name: String\n  count: Int!\n  operators: [Operator!]\n}\n\ntype RouteStop {\n  id: Int!\n  stop_id: Int!\n  route_id: Int!\n  agency_id: Int!\n  route: Route!\n  stop: Stop!\n  agency: Agency!\n}\n\ntype RouteStopPattern {\n  stop_pattern_id: Int!\n  direction_id: Int!\n  count: Int!\n  trips(limit: Int): [Trip!]\n}\n\ntype RouteGeometry {\n  \"If true, the source GTFS feed provides no shapes. This route geometry is based on straight lines between stop points.\"\n  generated: Boolean!\n  geometry: LineString\n  combined_geometry: Geometry\n  length: Float\n  max_segment_length: Float\n  first_point_max_distance: Float\n}\n\ntype RouteHeadway {\n  \n}\n\n\"\"\"\nMTC GTFS+ Extension: route_attributes.txt\n\"\"\"\ntype RouteAttribute {\n  category: Int\n  subcategory: Int\n  running_way: Int\n}\n\n# Census entities\n\ntype CensusGeography {\n  id: Int!\n  layer_name: String!\n  geoid: String\n  name: String\n  aland: Float\n  awater: Float\n  geometry: Polygon\n  values(table_names: [String!]!, limit: Int): [CensusValue]!\n}\n\ntype CensusValue {\n  table: CensusTable!\n  values: Any! # json blob\n}\n\ntype CensusTable {\n  id: Int!\n  table_name: String!\n  table_title: String!\n  table_group: String!\n}\n\n# Realtime updates\n\nenum ScheduleRelationship {\n  SCHEDULED\n  ADDED\n  UNSCHEDULED\n  CANCELED\n}\n\ntype StopTimeEvent {\n  stop_timezone: String!\n  scheduled: Seconds\n  estimated: Seconds\n  estimated_utc: Time\n  delay: Int\n  uncertainty: Int\n}\n\n\"\"\"\n[Vehicle Position](https://gtfs.org/reference/realtime/v2/#message-vehicleposition) message provided by a source GTFS Realtime feed.\n\"\"\"\ntype VehiclePosition {\n  vehicle: RTVehicleDescriptor\n  position: Point\n  current_stop_sequence: Int\n  stop_id: Stop\n  current_status: String\n  timestamp: Time\n  congestion_level: String\n}\n\n\"\"\"\n[Alert](https://gtfs.org/reference/realtime/v2/#message-alert) message, also called a service alert, provided by a source GTFS Realtime feed.\n\"\"\"\ntype Alert {\n  active_period: [RTTimeRange!]\n  cause: String\n  effect: String\n  header_text: [RTTranslation!]!\n  description_text: [RTTranslation!]!\n  tts_header_text: [RTTranslation!]\n  tts_description_text: [RTTranslation!]\n  url: [RTTranslation!]\n  severity_level: String\n}\n\n\"\"\"\nSee https://gtfs.org/reference/realtime/v2/#message-timerange\n\"\"\"\ntype RTTimeRange {\n  start: Int\n  end: Int\n}\n\n\"\"\"\nSee https://gtfs.org/reference/realtime/v2/#message-vehicledescriptor\n\"\"\"\ntype RTVehicleDescriptor {\n  id: String\n  label: String\n  license_plate: String\n}\n\n\"\"\"\nSee https://gtfs.org/reference/realtime/v2/#message-tripdescriptor\n\"\"\"\ntype RTTripDescriptor {\n  trip_id: String\n  route_id: String\n  direction_id: Int\n  start_time: Seconds\n  start_date: Date\n  schedule_relationship: String\n}\n\n\"\"\"\nSee https://gtfs.org/reference/realtime/v2/#message-translatedstring\n\"\"\"\ntype RTTranslation {\n  text: String!\n  language: String\n}\n\n\n# Analysis tools\n\ntype RouteStopBuffer {\n  stop_points: Geometry\n  stop_buffer: Geometry\n  stop_convexhull: Polygon\n}\n\n# Validation tools\n\ntype ValidationReport {\n  # Validation output\n  id: Int!\n  success: Boolean!\n  failure_reason: String!\n  errors(limit: Int): [ValidationReportErrorGroup!]! @goField(forceResolver: true)\n  warnings(limit: Int): [ValidationReportErrorGroup!]! @goField(forceResolver: true)\n  details: ValidationReportDetails @goField(forceResolver: true)\n}\n\ntype ValidationReportDetails {\n  sha1: String!\n  earliest_calendar_date: Date\n  latest_calendar_date: Date\n  files: [FeedVersionFileInfo!]!\n  service_levels(limit: Int, route_id: String): [FeedVersionServiceLevel!]!\n  agencies(limit: Int): [Agency!]!\n  routes(limit: Int): [Route!]!\n  stops(limit: Int): [Stop!]!\n  feed_infos(limit: Int): [FeedInfo!]!\n  realtime: [ValidationRealtimeResult!]\n}\n\ntype ValidationRealtimeResult {\n  url: String!\n  json: Map\n}\n\ntype ValidationReportErrorGroup {\n  filename: String!\n  error_type: String!\n  error_code: String!\n  message: String!\n  field: String!\n  count: Int!\n  limit: Int!\n  errors(limit: Int): [ValidationReportError!]! @goField(forceResolver: true)\n}\n\ntype ValidationReportError {\n  filename: String!\n  error_type: String!\n  error_code: String!\n  entity_id: String!\n  field: String!\n  line: Int!\n  value: String!\n  message: String!\n  geometry: Geometry\n}\n\ntype FeedVersionFetchResult {\n  feed_version: FeedVersion\n  fetch_error: String\n  found_sha1: Boolean!\n  found_dir_sha1: Boolean!\n}\n\ntype FeedVersionImportResult {\n  success: Boolean!\n}\n\ntype FeedVersionUnimportResult {\n  success: Boolean!\n}\n\ntype FeedVersionDeleteResult {\n  success: Boolean!\n}\n",
  "expected": "stop: Stop!\n  dow_category: Int\n  direction_id: Int\n  headway_secs: Int\n  service_date: Date\n  stop_trip_count: Int\n  departures: [Seconds!]",
  "offset": 17384,
  "instruction": "El fragmento describe un objeto \"stop\" que contiene información sobre una parada de transporte, incluyendo su categoría, dirección, frecuencia de paso, fecha de servicio, conteo de viajes y horarios de salidas."
}