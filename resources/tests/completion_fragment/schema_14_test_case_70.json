{
  "context": "directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION\n\n\"\"\"See https://gtfs.org/schedule/reference/#agencytxt\"\"\"\ntype Agency {\n  agency_email: String!\n  agency_fare_url: String!\n  agency_id: String!\n  agency_lang: String!\n  agency_name: String!\n  agency_phone: String!\n  agency_timezone: String!\n  agency_url: String!\n  alerts(active: Boolean, limit: Int): [Alert!]\n  census_geographies(layer: String!, limit: Int, radius: Float): [CensusGeography!]\n  feed_onestop_id: String\n  feed_version: FeedVersion!\n  feed_version_sha1: String\n  geometry: Polygon\n  id: Int!\n  onestop_id: String!\n  operator: Operator\n  places(limit: Int, where: AgencyPlaceFilter): [AgencyPlace!]\n  routes(limit: Int, where: RouteFilter): [Route!]!\n  search_rank: String\n}\n\ninput AgencyFilter {\n  \"\"\"Search by country 2 letter ISO 3166 code (provided by Natural Earth)\"\"\"\n  adm0_iso: String\n\n  \"\"\"Search by country name (provided by Natural Earth)\"\"\"\n  adm0_name: String\n\n  \"\"\"\n  Search by state/province/division ISO 3166-2 code (provided by Natural Earth)\n  \"\"\"\n  adm1_iso: String\n\n  \"\"\"Search by state/province/division name (provided by Natural Earth)\"\"\"\n  adm1_name: String\n  agency_id: String\n\n  \"\"\"Search for records with this GTFS agency_name\"\"\"\n  agency_name: String\n  bbox: BoundingBox\n\n  \"\"\"Search by city name (provided by Natural Earth)\"\"\"\n  city_name: String\n  feed_onestop_id: String\n  feed_version_sha1: String\n  license: LicenseFilter\n\n  \"\"\"Search for agencies within a radius\"\"\"\n  near: PointRadius\n  onestop_id: String\n\n  \"\"\"Full text search\"\"\"\n  search: String\n  within: Polygon\n}\n\ntype AgencyPlace {\n  adm0_iso: String\n  adm0_name: String\n  adm1_iso: String\n  adm1_name: String\n  city_name: String\n  rank: Float\n}\n\ninput AgencyPlaceFilter {\n  min_rank: Float\n}\n\n\"\"\"\n[Alert](https://gtfs.org/reference/realtime/v2/#message-alert) message, also called a service alert, provided by a source GTFS Realtime feed.\n\"\"\"\ntype Alert {\n  active_period: [RTTimeRange!]\n  cause: String\n  description_text: [RTTranslation!]!\n  effect: String\n  header_text: [RTTranslation!]!\n  severity_level: String\n  tts_description_text: [RTTranslation!]\n  tts_header_text: [RTTranslation!]\n  url: [RTTranslation!]\n}\n\nscalar Any\n\nscalar Bool\n\ninput BoundingBox {\n  max_lat: Float!\n  max_lon: Float!\n  min_lat: Float!\n  min_lon: Float!\n}\n\n\"\"\"\nRecord from a static GTFS [calendars.txt](https://gtfs.org/schedule/reference/#calendarstxt) file.\n\"\"\"\ntype Calendar {\n  added_dates(limit: Int): [Date!]!\n  end_date: Date!\n  friday: Int!\n  id: Int!\n  monday: Int!\n  removed_dates(limit: Int): [Date!]!\n  saturday: Int!\n  service_id: String!\n  start_date: Date!\n  sunday: Int!\n  thursday: Int!\n  tuesday: Int!\n  wednesday: Int!\n}\n\ninput CalendarDateFilter {\n  date: Date\n  exception_type: Int\n}\n\ntype CensusGeography {\n  aland: Float\n  awater: Float\n  geoid: String\n  geometry: Polygon\n  id: Int!\n  layer_name: String!\n  name: String\n  values(limit: Int, table_names: [String!]!): [CensusValue]!\n}\n\ntype CensusTable {\n  id: Int!\n  table_group: String!\n  table_name: String!\n  table_title: String!\n}\n\ntype CensusValue {\n  table: CensusTable!\n  values: Any!\n}\n\nscalar Counts\n\nscalar Date\n\ninput DirectionRequest {\n  depart_at: Time\n  from: WaypointInput!\n  mode: StepMode!\n  to: WaypointInput!\n}\n\ntype Directions {\n  data_source: String\n  destination: Waypoint\n  distance: Distance\n  duration: Duration\n  end_time: Time\n  exception: String\n  itineraries: [Itinerary!]\n  origin: Waypoint\n  start_time: Time\n  success: Boolean!\n}\n\ntype Distance {\n  distance: Float!\n  units: DistanceUnit!\n}\n\nenum DistanceUnit {\n  KILOMETERS\n  MILES\n}\n\ntype Duration {\n  duration: Float!\n  units: DurationUnit!\n}\n\nenum DurationUnit {\n  SECONDS\n}\n\n\"\"\"\nFeeds contain details on how to access transit information, including URLs to data sources in various formats (GTFS, GTFS-RT, GBFS, etc), license information, related feeds, details on how to make authorized requests, and feed version archives. Feed versions are archived (as `.zip` files) and imported into the Transitland database for querying agencies, stops, routes, trips, etc.\n\"\"\"\ntype Feed {\n  associated_operators: [Operator!]\n  authorization: FeedAuthorization\n  feed_fetches(limit: Int, where: FeedFetchFilter): [FeedFetch!]\n  feed_state: FeedState\n\n  \"\"\"\n  Versions of this feed that have been fetched, archived, and imported by Transitland\n  \"\"\"\n  feed_versions(limit: Int, where: FeedVersionFilter): [FeedVersion!]!\n  file: String!\n\n  \"\"\"Unique integer ID\"\"\"\n  id: Int!\n\n  \"\"\"Language(s) included in this feed\"\"\"\n  languages: [String!]\n  license: FeedLicense\n\n  \"\"\"\n  A common name for this feed. Optional. Alternatively use `associated_operators[].name`\n  \"\"\"\n  name: String\n\n  \"\"\"Onestop ID for this feed\"\"\"\n  onestop_id: String!\n  search_rank: String\n  spec: FeedSpecTypes\n  tags: Tags\n  urls: FeedUrls\n}\n\n\"\"\"\nDetails on how to construct an HTTP request to access a protected resource\n\"\"\"\ntype FeedAuthorization {\n  \"\"\"Website to visit to sign up for an account\"\"\"\n  info_url: String!\n\n  \"\"\"\n  When `type=query_param`, this specifies the name of the query parameter. When `type=header`, this specifies the name of the header\n  \"\"\"\n  param_name: String!\n\n  \"\"\"Method for inserting authorization secret into request\"\"\"\n  type: String!\n}\n\ntype FeedFetch {\n  fetch_error: String\n  fetched_at: Time\n  id: Int!\n  response_code: Int\n  response_sha1: String\n  response_size: Int\n  success: Boolean\n  url: String\n  url_type: String\n}\n\ninput FeedFetchFilter {\n  success: Boolean\n}\n\ninput FeedFilter {\n  bbox: BoundingBox\n\n  \"\"\"Search for feeds with or without a fetch error\"\"\"\n  fetch_error: Boolean\n\n  \"\"\"Search for feeds by their import status\"\"\"\n  import_status: ImportStatus\n  license: LicenseFilter\n  near: PointRadius\n\n  \"\"\"Search for feed with a specific Onestop ID\"\"\"\n  onestop_id: String\n\n  \"\"\"Full text search\"\"\"\n  search: String\n\n  \"\"\"Search for feeds by their source URLs\"\"\"\n  source_url: FeedSourceUrl\n\n  \"\"\"Search for feeds of certain data types\"\"\"\n  spec: [FeedSpecTypes!]\n\n  \"\"\"Search for feeds with a tag\"\"\"\n  tags: Tags\n  within: Polygon\n}\n\n\"\"\"\nRecord from a static GTFS [feed_info.txt](https://gtfs.org/schedule/reference/#feed_infotxt) file.\n\"\"\"\ntype FeedInfo {\n  default_lang: String\n  feed_contact_email: String\n  feed_contact_url: String\n  feed_end_date: Date\n  feed_lang: String!\n  feed_publisher_name: String!\n  feed_publisher_url: String!\n  feed_start_date: Date\n  feed_version: String!\n  id: Int!\n}\n\n\"\"\"\nLicense information for this feed, curated by Interline and contributors to the Transitland Atlas feed registry. Note that this does not constitute legal advice. Users are advised to review and confirm any terms and conditions attached to a source feed.\n\"\"\"\ntype FeedLicense {\n  \"\"\"\n  Feed consumers must follow these instructions for how to provide attribution\n  \"\"\"\n  attribution_instructions: String!\n\n  \"\"\"Feed consumers must include this particular text when using this feed\"\"\"\n  attribution_text: String!\n\n  \"\"\"Are feed consumers allowed to use the feed for commercial purposes?\"\"\"\n  commercial_use_allowed: String!\n\n  \"\"\"\n  Are feed consumers allowed to create and share derived products from the feed?\n  \"\"\"\n  create_derived_product: String!\n\n  \"\"\"Are feed consumers allowed to redistribute the feed in its entirety?\"\"\"\n  redistribution_allowed: String!\n\n  \"\"\"\n  Are feed consumers allowed to keep their modifications of this feed private?\n  \"\"\"\n  share_alike_optional: String!\n\n  \"\"\"SPDX identifier for a common license. See https://spdx.org/licenses/\"\"\"\n  spdx_identifier: String!\n\n  \"\"\"URL for a custom license\"\"\"\n  url: String!\n\n  \"\"\"\n  Are feed consumers allowed to use the feed contents without including attribution text in their app or map?\n  \"\"\"\n  use_without_attribution: String!\n}\n\ninput FeedSourceUrl {\n  case_sensitive: Boolean\n  type: FeedSourceUrlTypes\n  url: String\n}\n\nenum FeedSourceUrlTypes {\n  gbfs_auto_discovery\n  mds_provider\n  realtime_alerts\n  realtime_trip_updates\n  realtime_vehicle_positions\n  static_current\n  static_historic\n  static_hypothetical\n  static_planned\n}\n\n\"\"\"Type of data contained in a source feed\"\"\"\nenum FeedSpecTypes {\n  GBFS\n  GTFS\n  GTFS_RT\n  MDS\n}\n\n\"\"\"\nDetails on the current state of this feed, such as active version, last fetch time, etc.\n\"\"\"\ntype FeedState {\n  \"\"\"The active feed version for this feed\"\"\"\n  feed_version: FeedVersion\n  id: Int!\n}\n\n\"\"\"URL(s) from which Transitland sources a feed\"\"\"\ntype FeedUrls {\n  \"\"\"URL for GBFS feed `gbfs.json` auto-discovery file\"\"\"\n  gbfs_auto_discovery: String!\n\n  \"\"\"URL for MDS feed provider endpoint\"\"\"\n  mds_provider: String!\n\n  \"\"\"URL for GTFS Realtime Alert messages\"\"\"\n  realtime_alerts: String!\n\n  \"\"\"URL for GTFS Realtime TripUpdate messages\"\"\"\n  realtime_trip_updates: String!\n\n  \"\"\"URL for GTFS Realtime VehiclePosition messages\"\"\"\n  realtime_vehicle_positions: String!\n\n  \"\"\"URL for the static feed that represents today's service\"\"\"\n  static_current: String!\n\n  \"\"\"\n  URLs for static feeds that represent past service that is no longer in effect \n  \"\"\"\n  static_historic: [String!]!\n\n  \"\"\"\n  URLs for static feeds that represent service planned for upcoming dates. Typically used to represent calendar/service changes that will take effect few weeks or months in the future\n  \"\"\"\n  static_planned: String!\n}\n\n\"\"\"\nFeed versions represent a specific static GTFS file that was published at a particular point in time, and are generally accessed and referenced using the [SHA1 checksum](https://en.wikipedia.org/wiki/SHA-1) of the GTFS archive.\n\"\"\"\ntype FeedVersion {\n  agencies(limit: Int, where: AgencyFilter): [Agency!]!\n  created_by: String\n  description: String\n  earliest_calendar_date: Date!\n  feed: Feed!\n  feed_infos(limit: Int): [FeedInfo!]!\n  feed_version_gtfs_import: FeedVersionGtfsImport\n  fetched_at: Time!\n  file: String\n\n  \"\"\"\n  Metadata for each text file present in the main directory of the zip archive \n  \"\"\"\n  files(limit: Int): [FeedVersionFileInfo!]!\n\n  \"\"\"Convex hull around all active stops in the feed version\"\"\"\n  geometry: Polygon\n  id: Int!\n  latest_calendar_date: Date!\n  name: String\n  routes(limit: Int, where: RouteFilter): [Route!]!\n  service_levels(limit: Int, where: FeedVersionServiceLevelFilter): [FeedVersionServiceLevel!]!\n  sha1: String!\n  stops(limit: Int, where: StopFilter): [Stop!]!\n  trips(limit: Int, where: TripFilter): [Trip!]!\n  updated_by: String\n  url: String!\n  validation_reports(limit: Int, where: ValidationReportFilter): [ValidationReport!]\n}\n\ntype FeedVersionDeleteResult {\n  success: Boolean!\n}\n\ntype FeedVersionFetchResult {\n  feed_version: FeedVersion\n  fetch_error: String\n  found_dir_sha1: Boolean!\n  found_sha1: Boolean!\n}\n\ntype FeedVersionFileInfo {\n  csv_like: Boolean!\n  header: String!\n  id: Int!\n  name: String!\n  rows: Int!\n  sha1: String!\n  size: Int!\n  values_count: Counts!\n  values_unique: Counts!\n}\n\ninput FeedVersionFilter {\n  bbox: BoundingBox\n  covers: ServiceCoversFilter\n  feed_ids: [Int!]\n  feed_onestop_id: String\n  file: String\n  import_status: ImportStatus\n  near: PointRadius\n  sha1: String\n  within: Polygon\n}\n\ntype FeedVersionGtfsImport {\n  created_at: Time\n  entity_count: Any\n  exception_log: String!\n  id: Int!\n  in_progress: Boolean!\n  interpolated_stop_time_count: Int\n  schedule_removed: Boolean!\n  skip_entity_error_count: Any\n  skip_entity_filter_count: Any\n  skip_entity_marked_count: Any\n  skip_entity_reference_count: Any\n  success: Boolean!\n  updated_at: Time\n  warning_count: Any\n}\n\ntype FeedVersionImportResult {\n  success: Boolean!\n}\n\ntype FeedVersionServiceLevel {\n  end_date: Date!\n  friday: Int!\n  id: Int!\n  monday: Int!\n  saturday: Int!\n  start_date: Date!\n  sunday: Int!\n  thursday: Int!\n  tuesday: Int!\n  wednesday: Int!\n}\n\ninput FeedVersionServiceLevelFilter {\n  end_date: Date\n  start_date: Date\n}\n\ninput FeedVersionSetInput {\n  description: String\n  name: String\n}\n\ntype FeedVersionUnimportResult {\n  success: Boolean!\n}\n\n\"\"\"\nRecord from a static GTFS [frequencies.txt](https://gtfs.org/schedule/reference/#frequenciestxt) file.\n\"\"\"\ntype Frequency {\n  end_time: Seconds!\n  exact_times: Int!\n  headway_secs: Int!\n  id: Int!\n  start_time: Seconds!\n}\n\ntype GbfsAlertTime {\n  end: Int\n  start: Int\n}\n\ninput GbfsBikeRequest {\n  near: PointRadius\n}\n\ntype GbfsBrandAsset {\n  brand_image_url: String\n  brand_image_url_dark: String\n  brand_last_modified: Date\n  brand_terms_url: String\n  color: String\n}\n\ninput GbfsDockRequest {\n  near: PointRadius\n}\n\ntype GbfsFeed {\n  alerts: [GbfsSystemAlert!]\n  calendars: [GbfsSystemCalendar!]\n  rental_hours: [GbfsSystemHour!]\n  station_information: [GbfsStationInformation!]\n  system_information: GbfsSystemInformation\n}\n\ntype GbfsFreeBikeStatus {\n  available_until: Int\n  bike_id: String\n  current_fuel_percent: Float\n  current_range_meters: Float\n  feed: GbfsFeed\n  home_station: GbfsStationInformation\n  is_disabled: Bool\n  is_reserved: Bool\n  last_reported: Int\n  lat: Float\n  lon: Float\n  pricing_plan: GbfsSystemPricingPlan\n  rental_uris: GbfsRentalUris\n  station: GbfsStationInformation\n  vehicle_equipment: Strings\n  vehicle_type: GbfsVehicleType\n}\n\ntype GbfsGeofenceFeature {\n  geometry: Geometry\n  type: String\n}\n\ntype GbfsGeofenceProperty {\n  end: Int\n  name: String\n  rules: [GbfsGeofenceRule]\n  start: Int\n}\n\ntype GbfsGeofenceRule {\n  maximum_speed_kph: Int\n  ride_allowed: Bool\n  ride_through_allowed: Bool\n  station_parking: Bool\n  vehicle_type: GbfsVehicleType\n}\n\ntype GbfsGeofenceZone {\n  features: [GbfsGeofenceFeature!]\n  type: String\n}\n\ntype GbfsPlanPrice {\n  end: Int\n  interval: Int\n  rate: Float\n  start: Int\n}\n\ntype GbfsRentalApp {\n  discovery_uri: String\n  store_uri: String\n}\n\ntype GbfsRentalApps {\n  android: GbfsRentalApp\n  ios: GbfsRentalApp\n}\n\ntype GbfsRentalUris {\n  android: String\n  ios: String\n  web: String\n}\n\ntype GbfsStationInformation {\n  address: String\n  capacity: Int\n  contact_phone: String\n  cross_street: String\n  feed: GbfsFeed\n  is_charging_station: Bool\n  is_valet_station: Bool\n  is_virtual_station: Bool\n  lat: Float\n  lon: Float\n  name: String\n  parking_hoop: Int\n  parking_type: String\n  post_code: String\n  region: GbfsSystemRegion\n  rental_methods: Strings\n  short_name: String\n  station_area: Geometry\n  station_id: String\n  status: GbfsStationStatus\n}\n\ntype GbfsStationStatus {\n  is_installed: Bool\n  is_renting: Bool\n  is_returning: Bool\n  last_reported: Int\n  num_bikes_available: Int\n  num_bikes_disabled: Int\n  num_docks_available: Int\n  num_docks_disabled: Int\n  station_id: String\n  vehicle_docks_available: [GbfsVehicleDockAvailable!]\n  vehicle_types_available: [GbfsVehicleTypeAvailable!]\n}\n\ntype GbfsSystemAlert {\n  alert_id: String\n  description: String\n  last_updated: Int\n  summary: String\n  times: [GbfsAlertTime!]\n  type: String\n  url: String\n}\n\ntype GbfsSystemCalendar {\n  end_day: Int\n  end_month: Int\n  end_year: Int\n  start_day: Int\n  start_month: Int\n  start_year: Int\n}\n\ntype GbfsSystemHour {\n  days: Strings\n  end_time: String\n  start_time: String\n  user_types: Strings\n}\n\ntype GbfsSystemInformation {\n  brand_assets: GbfsBrandAsset\n  email: String\n  feed_contact_email: String\n  language: String\n  license_url: String\n  name: String\n  operator: String\n  phone_number: String\n  privacy_last_updated: Date\n  privacy_url: String\n  purchase_url: String\n  rental_apps: GbfsRentalApps\n  short_name: String\n  start_date: Date\n  system_id: String\n  terms_last_updated: Date\n  terms_url: String\n  timezone: String\n  url: String\n}\n\ntype GbfsSystemPricingPlan {\n  currency: String\n  description: String\n  is_taxable: Bool\n  name: String\n  per_km_pricing: [GbfsPlanPrice!]\n  per_min_pricing: [GbfsPlanPrice!]\n  plan_id: String\n  price: Float\n  surge_pricing: Bool\n  url: String\n}\n\ntype GbfsSystemRegion {\n  name: String\n  region_id: String\n}\n\ntype GbfsSystemVersion {\n  url: String\n  version: String\n}\n\ntype GbfsVehicleAssets {\n  icon_last_modified: Date\n  icon_url: String\n  icon_url_dark: String\n}\n\ntype GbfsVehicleDockAvailable {\n  count: Int\n  vehicle_types: [GbfsVehicleType!]\n}\n\ntype GbfsVehicleType {\n  cargo_load_capacity: Int\n  cargo_volume_capacity: Int\n  color: String\n  country_code: String\n  default_pricing_plan: GbfsSystemPricingPlan\n  default_reserve_time: Int\n  eco_label: String\n  eco_sticker: String\n  form_factor: String\n  gco_2_km: Int\n  make: String\n  max_permitted_speed: Int\n  max_range_meters: Float\n  model: String\n  name: String\n  pricing_plans: [GbfsSystemPricingPlan!]\n  propulsion_type: String\n  rated_power: Int\n  rental_uris: GbfsRentalUris\n  return_constraint: String\n  rider_capacity: Int\n  vehicle_accessories: Strings\n  vehicle_assets: GbfsVehicleAssets\n  vehicle_image: String\n  vehicle_type_id: String\n  wheel_count: Int\n}\n\ntype GbfsVehicleTypeAvailable {\n  count: Int\n  num_bikes_disabled: Int\n  num_docks_available: Int\n  vehicle_type: GbfsVehicleType\n}\n\nscalar Geometry\n\nenum ImportStatus {\n  ERROR\n  IN_PROGRESS\n  SUCCESS\n}\n\ntype Itinerary {\n  \n}\n\nscalar Key\n\ntype Leg {\n  distance: Distance!\n  duration: Duration!\n  end_time: Time!\n  from: Waypoint\n  geometry: LineString!\n  start_time: Time!\n  steps: [Step!]\n  to: Waypoint\n}\n\n\"\"\"\nDescribe the different levels of a station. Is mostly useful when used in conjunction with pathways. See https://gtfs.org/reference/static/#levelstxt\n\"\"\"\ntype Level {\n  geometry: Polygon!\n  id: Int!\n  level_id: String!\n  level_index: Float!\n  level_name: String!\n  stops: [Stop!]\n}\n\ninput LicenseFilter {\n  commercial_use_allowed: LicenseValue\n  create_derived_product: LicenseValue\n  redistribution_allowed: LicenseValue\n  share_alike_optional: LicenseValue\n  use_without_attribution: LicenseValue\n}\n\nenum LicenseValue {\n  EXCLUDE_NO\n  NO\n  UNKNOWN\n  YES\n}\n\nscalar LineString\n\nscalar Map\n\ntype Me {\n  email: String\n  external_data: Map\n  id: String!\n  name: String\n  roles: [String!]\n}\n\n\"\"\"\nAn agency represents a single GTFS `agencies.txt` entity that was imported from a single feed version. The metadata, routes, etc., for an agency include only the data for that specific agency in that specific feed version. \n\nOperators are a higher-level abstraction over agencies, with each operator defined by an entry in the [Transitland Atlas](/documentation/atlas). Operators provide a method for enriching the basic GTFS agency data, as well as grouping agencies that span across multiple source feeds. Operators are matched with GTFS agencies using `associated_feeds`, a simple list of Feed OnestopIDs and GTFS `agency_id`s. For instance, the [Atlas operator record](https://github.com/transitland/transitland-atlas/blob/master/operators/o-dr5r-nyct.json) for the [New York City MTA](/operators/o-dr5r-nyct) has `associated_feeds` values for 8 different GTFS feeds. A query for this operator OnestopID thus represents the union of data from all 8 feeds, and includes routes for the subway, bus service for all 5 boroughs, commuter rail agencies, etc., operated by the MTA. This record also includes additional metadata about the MTA, such as the United States National Transit Database ID, Wikidata IDs, and alternate names for the agency. Operator records are created and maintained through pull requests to the Atlas json files and synchronized with the Transitland database on each commit.\n\"\"\"\ntype Operator {\n  agencies: [Agency!]\n  feeds(limit: Int, where: FeedFilter): [Feed!]\n  file: String\n  generated: Boolean!\n  id: Int!\n  name: String\n  onestop_id: String\n  search_rank: String\n  short_name: String\n  tags: Tags\n  website: String\n}\n\ninput OperatorFilter {\n  adm0_iso: String\n  adm0_name: String\n  adm1_iso: String\n  adm1_name: String\n  agency_id: String\n  bbox: BoundingBox\n  city_name: String\n  feed_onestop_id: String\n  license: LicenseFilter\n  merged: Boolean\n  near: PointRadius\n  onestop_id: String\n  search: String\n  tags: Tags\n  within: Polygon\n}\n\n\"\"\"\nThe GTFS-Pathways extension uses a graph representation to describe subway or train, with nodes (the locations) and edges (the pathways). See https://gtfs.org/reference/static/#pathwaystxt\n\"\"\"\ntype Pathway {\n  from_stop: Stop!\n  id: Int!\n  is_bidirectional: Int!\n  length: Float!\n  max_slope: Float!\n  min_width: Float!\n  pathway_id: String!\n  pathway_mode: Int!\n  reverse_signposted_as: String!\n  signposted_as: String!\n  stair_count: Int!\n  to_stop: Stop!\n  traversal_time: Int!\n}\n\ninput PathwayFilter {\n  pathway_mode: Int\n}\n\ntype Place {\n  adm0_name: String\n  adm1_name: String\n  city_name: String\n  count: Int!\n  operators: [Operator!]\n}\n\nenum PlaceAggregationLevel {\n  ADM0\n  ADM0_ADM1\n  ADM0_ADM1_CITY\n  ADM0_CITY\n  ADM1_CITY\n  CITY\n}\n\ninput PlaceFilter {\n  adm0_name: String\n  adm1_name: String\n  city_name: String\n  min_rank: Float\n}\n\nscalar Point\n\ninput PointRadius {\n  lat: Float!\n  lon: Float!\n  radius: Float!\n}\n\nscalar Polygon\n\ntype Query {\n  agencies(after: Int, ids: [Int!], limit: Int, where: AgencyFilter): [Agency!]!\n  bikes(limit: Int, where: GbfsBikeRequest): [GbfsFreeBikeStatus!]\n  directions(where: DirectionRequest!): Directions!\n  docks(limit: Int, where: GbfsDockRequest): [GbfsStationInformation!]\n  feed_versions(after: Int, ids: [Int!], limit: Int, where: FeedVersionFilter): [FeedVersion!]!\n  feeds(after: Int, ids: [Int!], limit: Int, where: FeedFilter): [Feed!]!\n  me: Me!\n  operators(after: Int, ids: [Int!], limit: Int, where: OperatorFilter): [Operator!]!\n  places(after: Int, level: PlaceAggregationLevel, limit: Int, where: PlaceFilter): [Place!]\n  routes(after: Int, ids: [Int!], limit: Int, where: RouteFilter): [Route!]!\n  stops(after: Int, ids: [Int!], limit: Int, where: StopFilter): [Stop!]!\n  trips(after: Int, ids: [Int!], limit: Int, where: TripFilter): [Trip!]!\n}\n\n\"\"\"See https://gtfs.org/reference/realtime/v2/#message-timerange\"\"\"\ntype RTTimeRange {\n  end: Int\n  start: Int\n}\n\n\"\"\"See https://gtfs.org/reference/realtime/v2/#message-translatedstring\"\"\"\ntype RTTranslation {\n  language: String\n  text: String!\n}\n\n\"\"\"See https://gtfs.org/reference/realtime/v2/#message-tripdescriptor\"\"\"\ntype RTTripDescriptor {\n  direction_id: Int\n  route_id: String\n  schedule_relationship: String\n  start_date: Date\n  start_time: Seconds\n  trip_id: String\n}\n\n\"\"\"See https://gtfs.org/reference/realtime/v2/#message-vehicledescriptor\"\"\"\ntype RTVehicleDescriptor {\n  id: String\n  label: String\n  license_plate: String\n}\n\n\"\"\"See https://gtfs.org/schedule/reference/#routestxt\"\"\"\ntype Route {\n  agency: Agency!\n  alerts(active: Boolean, limit: Int): [Alert!]\n  census_geographies(layer: String!, limit: Int, radius: Float): [CensusGeography!]\n  continuous_drop_off: Int\n  continuous_pickup: Int\n  feed_onestop_id: String!\n  feed_version: FeedVersion!\n  feed_version_sha1: String!\n  geometries(limit: Int): [RouteGeometry!]!\n  geometry: Geometry\n  headways(limit: Int): [RouteHeadway!]!\n  id: Int!\n  onestop_id: String\n  patterns: [RouteStopPattern!]\n  route_attribute: RouteAttribute\n  route_color: String!\n  route_desc: String!\n  route_id: String!\n  route_long_name: String!\n  route_short_name: String!\n  route_sort_order: Int!\n  route_stop_buffer(radius: Float): RouteStopBuffer!\n  route_stops(limit: Int): [RouteStop!]!\n  route_text_color: String!\n  route_type: Int!\n  route_url: String!\n  search_rank: String\n  stops(limit: Int, where: StopFilter): [Stop!]!\n  trips(limit: Int, where: TripFilter): [Trip!]!\n}\n\n\"\"\"MTC GTFS+ Extension: route_attributes.txt\"\"\"\ntype RouteAttribute {\n  category: Int\n  running_way: Int\n  subcategory: Int\n}\n\ninput RouteFilter {\n  agency_ids: [Int!]\n  allow_previous_onestop_ids: Boolean\n  bbox: BoundingBox\n  feed_onestop_id: String\n  feed_version_sha1: String\n  license: LicenseFilter\n  near: PointRadius\n  onestop_id: String\n  onestop_ids: [String!]\n  operator_onestop_id: String\n  route_id: String\n  route_type: Int\n  search: String\n  serviced: Boolean\n  within: Polygon\n}\n\ntype RouteGeometry {\n  combined_geometry: Geometry\n  first_point_max_distance: Float\n\n  \"\"\"\n  If true, the source GTFS feed provides no shapes. This route geometry is based on straight lines between stop points.\n  \"\"\"\n  generated: Boolean!\n  geometry: LineString\n  length: Float\n  max_segment_length: Float\n}\n\ntype RouteHeadway {\n  departures: [Seconds!]\n  direction_id: Int\n  dow_category: Int\n  headway_secs: Int\n  service_date: Date\n  stop: Stop!\n  stop_trip_count: Int\n}\n\ntype RouteStop {\n  agency: Agency!\n  agency_id: Int!\n  id: Int!\n  route: Route!\n  route_id: Int!\n  stop: Stop!\n  stop_id: Int!\n}\n\ntype RouteStopBuffer {\n  stop_buffer: Geometry\n  stop_convexhull: Polygon\n  stop_points: Geometry\n}\n\ntype RouteStopPattern {\n  count: Int!\n  direction_id: Int!\n  stop_pattern_id: Int!\n  trips(limit: Int): [Trip!]\n}\n\nenum ScheduleRelationship {\n  ADDED\n  CANCELED\n  SCHEDULED\n  UNSCHEDULED\n}\n\nscalar Seconds\n\ninput ServiceCoversFilter {\n  end_date: Date\n  fetched_after: Time\n  fetched_before: Time\n  start_date: Date\n}\n\n\"\"\"\nRecord from a static GTFS [shapes.txt](https://gtfs.org/schedule/reference/#shapestxt) file.\n\"\"\"\ntype Shape {\n  generated: Boolean!\n  geometry: LineString!\n  id: Int!\n  shape_id: String!\n}\n\ntype Step {\n  distance: Distance!\n  duration: Duration!\n  end_time: Time!\n  geometry_offset: Int!\n  instruction: String!\n  mode: StepMode!\n  start_time: Time!\n  to: Waypoint\n}\n\nenum StepMode {\n  AUTO\n  BICYCLE\n  LINE\n  TRANSIT\n  WALK\n}\n\n\"\"\"See https://gtfs.org/reference/static/#stopstxt\"\"\"\ntype Stop {\n  alerts(active: Boolean, limit: Int): [Alert!]\n  arrivals(limit: Int, where: StopTimeFilter): [StopTime!]!\n  census_geographies(layer: String!, limit: Int, radius: Float): [CensusGeography!]\n  children(limit: Int): [Stop!]\n  departures(limit: Int, where: StopTimeFilter): [StopTime!]!\n  directions(depart_at: Time, from: WaypointInput, mode: StepMode, to: WaypointInput): Directions!\n  external_reference: StopExternalReference\n  feed_onestop_id: String!\n  feed_version: FeedVersion!\n  feed_version_sha1: String!\n  geometry: Point!\n  id: Int!\n  level: Level\n  location_type: Int!\n  nearby_stops(limit: Int, radius: Float): [Stop!]\n  observations(limit: Int, where: StopObservationFilter): [StopObservation!]\n  onestop_id: String!\n  parent: Stop\n  pathways_from_stop(limit: Int): [Pathway!]!\n  pathways_to_stop(limit: Int): [Pathway!]!\n  place: StopPlace\n  platform_code: String\n  route_stops(limit: Int): [RouteStop!]!\n  search_rank: String\n  stop_code: String!\n  stop_desc: String!\n  stop_id: String!\n  stop_name: String!\n  stop_times(limit: Int, where: StopTimeFilter): [StopTime!]!\n  stop_timezone: String!\n  stop_url: String!\n  tts_stop_name: String\n  wheelchair_boarding: Int!\n  zone_id: String!\n}\n\ntype StopExternalReference {\n  id: Int!\n  inactive: Boolean\n  target_active_stop: Stop\n  target_feed_onestop_id: String\n  target_stop_id: String\n}\n\ninput StopFilter {\n  agency_ids: [Int!]\n  allow_previous_onestop_ids: Boolean\n  bbox: BoundingBox\n  feed_onestop_id: String\n  feed_version_sha1: String\n  license: LicenseFilter\n  location_type: Int\n  near: PointRadius\n  onestop_id: String\n  onestop_ids: [String!]\n  search: String\n  served_by_onestop_ids: [String!]\n  served_by_route_type: Int\n  serviced: Boolean\n  stop_code: String\n  stop_id: String\n  within: Polygon\n}\n\ntype StopObservation {\n  agency_id: String\n  from_stop_id: String\n  observed_arrival_time: Seconds\n  observed_departure_time: Seconds\n  route_id: String\n  schedule_relationship: String\n  scheduled_arrival_time: Seconds\n  scheduled_departure_time: Seconds\n  source: String\n  stop_sequence: Int\n  to_stop_id: String\n  trip_id: String\n  trip_start_date: Date\n  trip_start_time: Seconds\n}\n\ninput StopObservationFilter {\n  feed_version_id: Int!\n  source: String!\n  trip_start_date: Date!\n}\n\ntype StopPlace {\n  adm0_iso: String\n  adm0_name: String\n  adm1_iso: String\n  adm1_name: String\n}\n\n\"\"\"\nRecord from a static GTFS [stop_times.txt](https://gtfs.org/schedule/reference/#stop_timestxt) file.\n\"\"\"\ntype StopTime {\n  arrival: StopTimeEvent!\n  arrival_time: Seconds!\n  continuous_drop_off: Int\n  continuous_pickup: Int\n  departure: StopTimeEvent!\n  departure_time: Seconds!\n  drop_off_type: Int\n  interpolated: Int\n  pickup_type: Int\n  service_date: Date\n  shape_dist_traveled: Float\n  stop: Stop!\n  stop_headsign: String\n  stop_sequence: Int!\n  timepoint: Int\n  trip: Trip!\n}\n\ntype StopTimeEvent {\n  delay: Int\n  estimated: Seconds\n  estimated_utc: Time\n  scheduled: Seconds\n  stop_timezone: String!\n  uncertainty: Int\n}\n\ninput StopTimeFilter {\n  allow_previous_route_onestop_ids: Boolean\n  end: Seconds\n  end_time: Int\n  exclude_first: Boolean\n  exclude_last: Boolean\n  next: Int\n  route_onestop_ids: [String!]\n  service_date: Date\n  start: Seconds\n  start_time: Int\n  use_service_window: Boolean\n}\n\nscalar Strings\n\nscalar Tags\n\nscalar Time\n\n\"\"\"\nRecord from a static GTFS [trips.txt](https://gtfs.org/schedule/reference/#tripstxt) file optionally enriched with by GTFS Realtime [TripUpdate](https://gtfs.org/reference/realtime/v2/#message-tripupdate) and [Alert](https://gtfs.org/reference/realtime/v2/#message-alert) messages.\n\"\"\"\ntype Trip {\n  alerts(active: Boolean, limit: Int): [Alert!]\n  bikes_allowed: Int!\n  block_id: String!\n  calendar: Calendar!\n  direction_id: Int!\n  feed_version: FeedVersion!\n  frequencies(limit: Int): [Frequency!]!\n  id: Int!\n  route: Route!\n  schedule_relationship: ScheduleRelationship\n  shape: Shape\n  stop_pattern_id: Int!\n  stop_times(limit: Int, where: TripStopTimeFilter): [StopTime]!\n  timestamp: Time\n  trip_headsign: String!\n  trip_id: String!\n  trip_short_name: String!\n  wheelchair_accessible: Int!\n}\n\ninput TripFilter {\n  feed_onestop_id: String\n  feed_version_sha1: String\n  license: LicenseFilter\n  route_ids: [Int!]\n  route_onestop_ids: [String!]\n  service_date: Date\n  stop_pattern_id: Int\n  trip_id: String\n}\n\ninput TripStopTimeFilter {\n  end: Seconds\n  start: Seconds\n}\n\nscalar Upload\n\ntype ValidationRealtimeResult {\n  json: Map\n  url: String!\n}\n\ntype ValidationReport {\n  details: ValidationReportDetails\n  errors(limit: Int): [ValidationReportErrorGroup!]!\n  failure_reason: String!\n  id: Int!\n  success: Boolean!\n  warnings(limit: Int): [ValidationReportErrorGroup!]!\n}\n\ntype ValidationReportDetails {\n  agencies(limit: Int): [Agency!]!\n  earliest_calendar_date: Date\n  feed_infos(limit: Int): [FeedInfo!]!\n  files: [FeedVersionFileInfo!]!\n  latest_calendar_date: Date\n  realtime: [ValidationRealtimeResult!]\n  routes(limit: Int): [Route!]!\n  service_levels(limit: Int, route_id: String): [FeedVersionServiceLevel!]!\n  sha1: String!\n  stops(limit: Int): [Stop!]!\n}\n\ntype ValidationReportError {\n  entity_id: String!\n  error_code: String!\n  error_type: String!\n  field: String!\n  filename: String!\n  geometry: Geometry\n  line: Int!\n  message: String!\n  value: String!\n}\n\ntype ValidationReportErrorGroup {\n  count: Int!\n  error_code: String!\n  error_type: String!\n  errors(limit: Int): [ValidationReportError!]!\n  field: String!\n  filename: String!\n  limit: Int!\n  message: String!\n}\n\ninput ValidationReportFilter {\n  success: Boolean\n  validator: String\n}\n\n\"\"\"\n[Vehicle Position](https://gtfs.org/reference/realtime/v2/#message-vehicleposition) message provided by a source GTFS Realtime feed.\n\"\"\"\ntype VehiclePosition {\n  congestion_level: String\n  current_status: String\n  current_stop_sequence: Int\n  position: Point\n  stop_id: Stop\n  timestamp: Time\n  vehicle: RTVehicleDescriptor\n}\n\ntype Waypoint {\n  lat: Float!\n  lon: Float!\n  name: String\n}\n\ninput WaypointInput {\n  lat: Float!\n  lon: Float!\n  name: String\n}",
  "expected": "distance: Distance!\n  duration: Duration!\n  end_time: Time!\n  from: Waypoint!\n  legs: [Leg!]\n  start_time: Time!\n  to: Waypoint!",
  "offset": 16875,
  "instruction": "El fragmento describe un viaje que incluye distancia, duración, tiempos de inicio y fin, puntos de origen y destino, y segmentos del trayecto."
}